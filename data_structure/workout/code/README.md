# 10장 [그래프]

## 그래프의 추상 자료형

### GRAPH ADT

- IsEmpty():
- countVertex(): 정점의 수 반환
- countEdge(): 간선의 수 반환
- getEdge(u,v): 정점 u에서 정점 v로 연결된 간선을 반환
- degree(v): 정점 v의 차수를 반환
- adjacent(v): 정점 v에 인접한 모든 정점의 집합을 반환
- insertVertex(v): 그래프에 정점 v를 삽입
- insertEdge(u,v): 그래프에 간선 (u,v)를 삽입
- deleteVertex(v): 그래프의 정점 v를 삭제
- deleteEdge(v): 그래프의 간선 (u,v)를 삭제

### 깊이 우선 탐색 알고리즘

> 깊이 우선 탐색은 한 정점에서 시작하여 최대한 깊숙히 탐색하면서 진행
> 현재 정점에서 갈 수 있는 경로를 모두 탐색한 후 다음 결로로 이동
> 후입선출(LIFO) 구조의 스택을 사용하여 탐색 경로를 관리

def dfs(graph, start, visited = set()):

### 너비 우선 탐색 알고리즘

> 한 정점에서 시작하여 인접한 정점들을 우선적으로 탐색
> 현재 정점에서 인접한 정점들을 모두 탐색한 후 다음 단계로 이동
> 큐(Queue)를 사용하여 구현가능
> 선입선출(FIFO)구조의 큐를 사용하여 탐색 경로를 관리
> 주로 최단 경로 찾기, 네트워크 분석, 그래프의 최단 경로 등에 사용

def bfs(graph, start):

### 연결 성분 검사 알고리즘

> 그래프의 임의의 정점을 선택하고, DFS를 통해 연결되어 잇는 모든 정점들을 출력
> 더이상 연결된 정점이 없으면 그래프에서 아직 방문하지 않은 다른 정점을 선택해 동일 과정을 수행
> 그래프의 모든 정점을 방문할 때까지 반복

def find_connected_component(graph):

def dfs_cc(graph, color, vertex, visited):

### 신장 트리 알고리즘

> 신장 트리 알고리즘은 그래프에서 모든 정점을 포함하면서 사이클이 없는 부분 그래프인 신장 트리를 찾는 알고리즘입니다.
> 신장 트리는 원래 그래프의 모든 정점을 포함하면서, 최소한의 간선만으로 연결된 트리입니다.
> eg. Kruskal 알고리즘 / Prim 알고리즘

def bfsST(graph, start):

### 위상 정렬 알고리즘

> 위상 정렬 알고리즘은 방향 그래프에서 정점들을 선형적으로 정렬하는 알고리즘입니다. 정렬된 순서는 그래프의 방향성을 유지하면서 모든 정점이 선행 정점보다 앞에 위치하도록 합니다.
> 즉, 그래프 내의 각 정점들이 선행 정점을 가리키는 방향성을 가지면서 사이클이 없는 순서를 찾아냅니다.
> 위상 정렬은 작업의 우선 순위, 의존 관계, 선후 조건 등을 표현하고 해결하는 데 사용됩니다.

def topological_sort_AM(vertex, graph):

# 11장 가중치그래프

### 인접 행렬을 이용한 표현

### 인접 행렬: 간단한 연산

### 인접 리스트를 이용한 표현

### union-find 구현

### Kruskal 알고리즘의 구현

### Prim의 알고리즘

### Dijkstra 최단경로 알고리즘

### Floyd의 최단 경로 알고리즘

# 12장 고급 정렬

### 셀 정렬

- 배열 전체를 한꺼번에 정렬하지 않고 전처리를 통해 처리시간을 줄임
- 리스트를 일정 기준에 따라 여러 개의 부분 리스트로 나눔
- 다시 전체 리스트를 더 적은 개수의 부분 리스트로 만들어 앞의 과정을 반복

[장점]

- 원거리 자료 이동을 통해 보다 적은 위치교환으로 제자리 찾을 가능성 증대
- 부분 리스트가 점진적으로 정렬된 상태가 되므로 삽입정렬 속도가 증가
- 비교 연산, 교환 연산 감소

[시간복잡도]

- 최악의 경우: O(n^2), 최선의 경우: O(nlogn)
- 평균적인 경우: O(n^1.5)

### 힙 정렬(Heapify 알고지즘)

### 병합 정렬

### 퀵 정렬

### 이중피벗 퀵 정렬

### 기수, 카운팅 정렬

### 정렬 알고리즘의 성능 비교
